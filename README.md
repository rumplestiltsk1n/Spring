# Принцип инверсии управления и внедрение зависимостей. Использование Spring Core для внедрения зависимостей

Любое мало-мальски серьезное приложение состоит из нескольких классов, которые взаимодействуют друг с другом, чтобы реализовывать бизнес-логику. Обычно, каждый объект отвечает за получение ссылок на другие объекты, с которыми он взаимодействует (такие другие объекты называются **зависимостями**, **dependencies**). Такой подход может привести к созданию тесно связанного кода, который тяжело тестировать.

Рассмотрим небольшой участок кода, который состоит из класса `User` и класса `Sender`.

```java
public class User {

    public void sendMessage(String message, String target) {
        Sender sender = new Sender();
        sender.send(message, target);
    }
}

public class Sender {

    public void send(String message, String target) {
        System.out.println("Tweet: " + message + " to " + target);
    }
}
```

В результате мы получим тесно связанный код – класс `User` теперь напрямую зависит от класса `Sender`. Таким образом, если мы создадим класс `EmailSender`, который будет отсылать сообщения по электронной почте, то чтобы использовать объект класса `EmailSender`, нам придется изменять код класса `User`. К тому же, тестирование метода `sendMessage()` будет затруднительным.

Безусловно, мы не можем избежать связывания вообще, т.к. объектно-ориентированное программирование подразумевает взаимодействие множества объектов различных классов, программа из одного класса не имеет смысла. С другой стороны, нам необходимо избегать **тесного связывания** (**tight coupling**) классов, так как такой код тяжело повторно использовать, тестировать и тяжело понять, как это всё вместе работает.

В противовес тесному связыванию кода существует принцип слабо связного (**loose coupling**) кода. Слабая связность означает, что изменения, вносимые в один класс, повлекут за собой небольшие изменения в другие классы, что упростит тестирование, рефакторинг, повторное использование кода. Приложение с использованием принципа слабо связного кода легче модифицируется и поддерживается.

## Инверсия управления

Одним из приемов для написания слабо связного кода является принцип **инверсии управления** (**Inversion of Control**, IoC). Он заключается в том, что жизненным циклом (созданием, вызовом методов и уничтожением) ваших объектов управляете не вы сами, а некий сторонний код. Отсюда и термин «инверсия» – не я управляю кодом, а сторонний код управляет моими классами. Он решает, когда создавать объекты моих классов, когда вызывать их методы и когда уничтожать объекты. На принципе инверсии управления базируется работа всех фреймворков.

> Подробно читайте про инверсию контроля [в оригинале](http://martinfowler.com/bliki/InversionOfControl.html) или [в переводе](https://habr.com/post/116232/).

Отличие библиотеки от фреймворка состоит в том, что библиотека – это по существу набор функций, организованных в классы, которые вы можете вызывать по мере надобности. Каждый вызов выполняет некоторую работу и возвращает управление обратно пользователю.

С другой стороны, фреймворк воплощает в себе некоторый абстрактный дизайн приложения со своим поведением. Для того, чтобы использовать его, вы должны добавить свой код в различные места фреймворка, либо через наследование, либо подключив свой собственный класс. Код фреймворка впоследствии будет вызывать ваш код.

## Внедрение зависимостей

Одной из реализаций принципа инверсии управления является **внедрение зависимостей** (**Dependency Injection**, DI). Это принцип заключается в том, что зависимости класса не создаются или ищутся в самом классе, а **внедряются** (**inject**) извне некоторым другим внешним источником (например, каким-то другим объектом).

В статье Мартина Фаулера «Inversion of Control Containers and the Dependency Injection pattern» этот объект называется **сборщиком** (**assembler**), а сейчас его обычно называют **контейнером** (**container**) или **IoC-контейнером** (**IoC-container**).

> Статья Мартина Фаулера - [оригинал](https://www.martinfowler.com/articles/injection.html), [перевод первой части](http://yugeon-dev.blogspot.com/2010/07/inversion-of-control-containers-and_21.html) и [перевод второй части](http://yugeon-dev.blogspot.com/2010/07/blog-post.html).

В общем случае, IoC-контейнер – это некоторый программный код (фреймворк, отдельный класс), который осуществляет внедрение зависимостей в приложении и, насколько это возможно, упрощает данный процесс.

Как правило, внедрение зависимости осуществляется через:

- конструктор класса (constructor injection);
- поле класса (field injection);
- входной аргумент метода (method injection), то есть через сеттер.

Внедрение через статические поля и методы не рекомендуется.
Фреймворк Spring, прежде чем стать многофункциональной платформой, изначально разрабатывался как IoC-контейнер для упрощения разработки JavaEE-приложений.

<p align="center">
  <img src="img/1.png" />
</p>

В приложениях на основе фреймворка Spring прикладные объекты располагаются внутри контейнера Spring. Как показано на рисунке, контейнер создает объекты, связывает их друг с другом, конфигурирует и управляет их полным жизненным циклом, от зарождения до самой их смерти (или от оператора new до вызова метода `finalize()`).

Классы, которыми управляет Spring-контейнер, называются бинами (bean) или компонентами. Контейнер создает, связывает между собой, а также уничтожает бины.

Фреймворк Spring имеет не один контейнер. В его состав входят несколько реализаций контейнера, которые подразделяются на два разных типа.
Фабрики компонентов (bean factories) (определяются интерфейсом `org.springframework.beans.factory.BeanFactory`) – самые простые из контейнеров, обеспечивающие базовую поддержку DI.

**Контекст приложений** (application context) (определяется интерфейсом `org.springframework.context.ApplicationContext`) основан на понятии фабрик компонентов и реализует прикладные службы фреймворка, такие как возможность приема текстовых сообщений из файлов свойств и возможность подписывать другие программные компоненты на события, возникающие в приложении.

С фреймворком Spring можно работать, используя и фабрики компонентов, и контексты приложений, но для большинства приложений фабрики компонентов часто оказываются слишком низкоуровневым инструментом. Поэтому контексты приложений выглядят более предпочтительно, чем фабрики компонентов.

В составе Spring имеется несколько разновидностей контекстов приложений. Три из них используются наиболее часто:

- `ClassPathXmlApplicationContext` – загружает определение контекста из XML-файла, расположенного в библиотеке классов (classpath), и обрабатывает файлы с определениями контекстов как ресурсы;
- `FileSystemXmlApplicationContext` – загружает определение контекста из XML-файла в файловой системе;
- `XmlWebApplicationContext` – загружает определение контекста из XML-файла, содержащегося внутри веб-приложения.

Давайте перепишем наш код, чтобы подготовить его к использованию IoC-контейнера Spring. Руководствуясь принципом Dependency Inversion (не путать с Dependency Injection, это разные принципы), создадим интерфейс Sender, чтобы не привязываться к конкретной реализации отправителя сообщений.

```java
public interface Sender {
    void sendMessage(String message, String target);
}
```

 Создадим класс `TwitterSender`, который реализует данный интерфейс.

 ```java
public class TwitterSender implements Sender {

    public void sendMessage(String message, String target) {
        System.out.println("Tweet: " + message + " is sending to " + target);
    }
}
 ```

Модифицируем класс `User`

```java
public class User {

    private Sender sender;

    public User(Sender sender) {
        this.sender = sender;
    }

    public void setSender(Sender sender) {
        this.sender = sender;
    }

    public void send(String message, String target) throws NullPointerException {
        if (sender != null) {
            sender.sendMessage(message, target);
        } else {
            throw new NullPointerException("Sender object is null");
        }
    }
}
```

Обратите внимание на разницу – мы теперь не сами создаем объект зависимости, а получаем его «извне» с помощью аргумента конструктора либо с помощью сеттера. Использование интерфейса позволяет легко использовать разные реализации отправщик сообщений. Еще одним бонусом является удобство проведения тестирования методов класса User, так как вместо настоящего отправщика сообщений мы можем подставить специальный мок-объект (mock object), который будет имитировать работу настоящего отправщика.

### Внедрение зависимости (wiring)

Итак, у нас есть соответствующие классы, теперь необходимо связывать это все воедино с помощью IoC-контейнера. Каким образом передать объект TwitterSender объекту User?

Процесс создания связи между компонентами приложения обычно называют wiring (в русской версии книги Spring in Action этот термин переводят как связывание, не путайте с сильным и слабым связыванием, которое переводится как tight coupling и loose coupling).

Подключим библиотеки Spring, которые нужны для связывания компонентов. Если вы используете Maven в качестве сборщика, от откройте pom-файл и добавьте следующие зависимости (на момент проведения занятия актуальная версия библиотек была 5.1.7, в вашем случае актуальная версия может быть другой)

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.0.17.RELEASE</version>
</dependency>

<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
    <version>5.0.17.RELEASE</version>
</dependency>
```

Важное отступление. Вы можете не добавлять библиотеку spring-core в pom-файл явно, код все равно будет работать. Это связано с тем, что spring-context не может работать без spring-core и Maven автоматически загрузит spring-core в любом случае, укажете ли вы ее в pom-файле или нет. В этом случае библиотека spring-core называется транзитивной зависимостью.

> Транзитивная зависимость - это зависимость, которая требуется для работы вашей прямой зависимости.

Такой механизм позволяет избежать ручного добавления в pom-файл всего графа зависимостей - вы просто указываете прямые зависимости, а Maven сделает все остальное.

Итак, вернемся к связыванию компонентов.

Важный момент, который необходимо запомнить при работе с контейнером - любой контейнер необходимо сконфигурировать. То есть, на плечи разработчика ложится обязанность указать контейнеру, какие компоненты создать и как их связать вместе.

Spring предлагает три способа связывания компонентов:

- явная конфигурация с помощью XML-файлов;
- явная конфигурация с помощью классов Java;
- неявное обнаружение бинов и автоматическое связывание.

В данном случае нет "самого лучшего" способа связывания, все три способа имеют право на жизнь. В данном занятии мы рассмотрим конфигурацию с помощью классов Java и автоматическое связывание.

### Конфигурация с помощью классов Java

Для начала создадим класс, в котором будет осуществляться конфигурация. Создадим пакет config и класс AppConfig. Так как в Spring может использоваться несколько способов связывания компонентов, то желательно пометить класс аннотацией @Configuration - такая аннотация говорит контейнеру, что этот класс является классом конфигурации.

```java
@Configuration
public class AppConfig {...}
```

Конфигурация в классе осуществляется с помощью методов и аннотаций. Добавим в класс следующий метод

```java
@Configuration
public class AppConfig {

    @Bean
    public TwitterSender twitterSender() {
        return new TwitterSender();
    }
}
```

Пометив метод аннотацией `@Bean`, мы говорим что данный метод возвращает объект, который который должен быть зарегистрирован как бин в контексте приложения Spring (то есть, в нашем IoC-контейнере). Таким образом, мы фактически объявляем бин в нашем контейнере. Название бина будет совпадать с названием метода, в нашем случа бин будет называться `twitterSender`.

Теперь добавим еще один метод

```java
@Configuration
public class AppConfig {

    @Bean
    public User user() {
        return new User(twitterSender());
    }

    @Bean
    public TwitterSender twitterSender() {
        return new TwitterSender();
    }
}
```

Объявляем еще один бин User и в методе осуществляем связывание бинов. В нашем случае мы осуществляем связывание через конструктор (constructor injection).

Таким образом, мы объявили два бина - twitterSender и user, после чего связали их с помощью constructor injection.

Теперь модифицируем класс Main, создадим контейнер и попробуем использовать класс User.

```java
public class Main {

    public static void main(String[] args) {

        AnnotationConfigApplicationContext context
                = new AnnotationConfigApplicationContext(AppConfig.class);

        User user = context.getBean(User.class);
        user.send("Hello!", "Nick");
    }
}
```

Итак, сначала мы создали объект контейнера. В качестве реализации мы используем класс `AnnotationConfigApplicationContext`, который является реализацией интерфейса `ApplicationContext`, которая позволяет регистрировать аннотированные классы конфигурации. В нашем случае классом конфигурации является класс `AppConfig`, объявленный с помощью аннотации `@Configuration`. После того как вы зарегистрируете указанный класс, также регистрируются все типы bean-компонентов, возвращаемые с помощью методов, которые аннотируются с помощью `@Bean`.

После создания контейнера и загрузки конфигурации, используем класс `User`. Обратите внимание, что мы не сами создаем объект класса `User` и внедряем зависимости, а мы просто получаем объект из контейнера, с помощью метода `getBean()`. После того, как мы получили ссылку на объект, вызываем метод `send()` и получаем работающий класс `User`. Проверим работу приложения.

```plain
июл 01, 2018 2:37:09 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh
INFO: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@4534b60d: startup date [Sun Jul 01 14:37:09 EEST 2018]; root of context hierarchy

Tweet: Hello! is sending to Nick
```

> Неплохой материал по поводу конфигурации с помощью классов можно почитать [здесь](https://www.tutorialspoint.com/spring/spring_java_based_configuration.htm) и [здесь](https://www.ibm.com/developerworks/ru/library/ws-springjava/index.html).

Таким образом мы реализовали связывание бинов с помощью контейнера Spring и конфигурации с помощью Java-классов. Теперь давайте рассмотрим автоматическое связывание.

### Автоматическое связывание

Способ автоматического связывания является наиболее простым в использовании.
Автоматическое связывание в Spring реализуется с помощью двух механизмов:

- сканирование компонентов (component scanning) – механизм, с помощью которого Spring обнаруживает и создает экземпляры компонентов;
- автосвязывание (autowiring) – механизм, с помощью которого Spring автоматически «удовлетворяет» зависимости компонентов (to satisfy a dependency).

Совместная работа этих механизмов обеспечивает минимальное явное конфигурирование контейнера.

Перепишем наш код для использования автоматического связывания. Для того, чтобы механизм сканирования компонентов обнаружил наши классы-бины, необходимо пометить их с помощью аннотации `@Component`.

```java
@Component
public class TwitterSender implements Sender {...}

@Component
public class User {...}
```

Тот участок кода, где контейнеру необходимо осуществить внедрение зависимости, аннотируется с помощью аннотации `@Autowired`. В рамках данного примера мы решили, что внедрение зависимости происходит в методе (method injection). Обратите внимание, что это не обязательно должен быть сеттер, хотя это крайне желательно

```java
@Component
public class User {

    private Sender sender;

    @Autowired
    public void setSender(Sender sender) {
        this.sender = sender;
    }
}
```

Когда мы осуществляли конфигурацию с помощью Java-класса, мы явно указывали классы компонентов и явно создавали объекты бинов.

Однако Spring способен автоматически отсканировать пакеты проекта, обнаружить бины и создать их экземпляры. Этот механизм называется сканирование компонентов (component scanning). По умолчанию, механизм сканирования компонентов отключен. Чтобы его включить, вернемся в конфигурационный класс `AppConfig` и укажем аннотацию `@ComponentScan` перед объявлением класса.

```java
@Configuration
@ComponentScan("app")
public class AppConfig {}
```

Прежде всего, удалим из класса AppConfig написанные ранее методы - они теперь не нужны.

Также обратите внимание, что в скобках был указан базовый пакет, где необходимо осуществить сканирование. Механизм сканирования компонентов будет искать компоненты в этом и в дочернем пакетах. Также вы можете указать параметр basePackages и перечислить пакеты для сканирования.

Запустим приложение и убедимся, что автоматическое связывание работает корректно.

```plain
июл 01, 2018 4:13:21 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh
INFO: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2d8e6db6: startup date [Sun Jul 01 16:13:21 EEST 2018]; root of context hierarchy

Tweet: Hello! is sending to Nick
```

### Разрешение зависимости (Dependency Resolution)

Использование автоматического связывания (связывание компонентов реализуется с помощью механизмов Spring) может привести к ситуации, когда будет существовать несколько бинов, которые могут быть использованы для связывания.

Пока что у нас был только один класс, который реализовывал интерфейс `Sender`. А что, если их будет два? Создадим класс `EmailSender`

```java
@Component
public class EmailSender implements Sender {

    public void sendMessage(String message, String target) {
        System.out.println("Email: " + message + " to: " + target);
    }
}
```

Запустим приложение

```plain
	at app.Main.main(Main.java:28)
Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'app.model.Sender' available: expected single matching bean but found 2: emailSender,twitterSender
```

Сообщение при исключении четко описывает проблему: есть два бина, которые можно внедрить в класс `User` и Spring не знает, какой из них следует внедрить и закрывается с исключением.

Чтобы избавиться от данной проблемы, можно дать указания контейнеру, какой из компонентов следует выбрать в том или ином случае (ищите информацию по аннотации `@Qualifier`).

В нашем примере воспользуемся аннотацией `@Conditional`, чтобы решить проблему нескольких кандидатов на связывание.

Аннотация `@Conditional` перед объявлением класса бина означает, что бин будет доступен для регистрации в контейнере только, когда будет удовлетворено некоторое условие. В нашем случае, для каждого кандидата мы создадим отдельный класс - реализацию интерфейса `Condition`, в котором реализуем специальный метод. Если метод вернет `true`, значит условие выполнено и компонент можно зарегистрировать.
Прежде всего воспользуемся механизмом properties в Java. Создадим ресурс `app.properties` с содержимым

```plain
sender.type = email
```

В классе Main создадим объект Properties и загрузим файл

```java
public class Main {

    public static final Properties config = new Properties();

    static {
        ClassLoader loader = Thread.currentThread().getContextClassLoader();

        try (InputStream resourceStream = loader.getResourceAsStream("app.properties")) {
            config.load(resourceStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Теперь у нас есть публичное статическое поле config, в котором хранятся свойства.

Создадим классы условий

```java
public class TwitterSenderCondition implements Condition {
    @Override
    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
        return Main.config.getProperty("sender.type").matches("twitter");
    }
}

public class EmailSenderCondition implements Condition {
    @Override
    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
        return Main.config.getProperty("sender.type").matches("email");
    }
}
```

В классах компонентов укажем аннотацию @Conditional и класс условия

```java
@Component
@Conditional(value = TwitterSenderCondition.class)
public class TwitterSender implements Sender {...}

@Component
@Conditional(value = EmailSenderCondition.class)
public class EmailSender implements Sender {...}
```

Теперь запустим приложение

```plain
июл 01, 2018 4:57:53 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh
INFO: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2d8e6db6: startup date [Sun Jul 01 16:57:53 EEST 2018]; root of context hierarchy

Email: Hello! to: Nick
```

Если мы изменим в app.properties значение с email на twitter и снова запустим приложение, то получим

```plain
июл 01, 2018 4:58:56 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh
INFO: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2d8e6db6: startup date [Sun Jul 01 16:58:56 EEST 2018]; root of context hierarchy

Tweet: Hello! is sending to Nick
```

Таким образом, проблема нескольких кандидатов решена.
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
# Клиент-серверная архитектура. Создание простой RESTful веб-службы с помощью Spring Boot

## Клиент-серверная архитектура

Сервер - компьютер или программа, которая управляет ресурсами (информация, файлы, база данных) называется сервером этого ресурса или просто сервером.

Архитектура "клиент-сервер" определяет общие принципы организации взаимодействия, где имеются серверы (узлы-поставщики некоторых специфичных функций и сервисов) и клиенты, (потребители этих сервисов).

Между клиентами и серверами должны быть установлены правила взаимодействия, которые называются протоколом взаимодействия или протоколом обмена. Каждая часть взаимодействует друг с другом, обмениваясь сообщениями в заранее согласованном формате.

> Подробнее про клиент-серверное взаимодействие читайте [здесь](http://bit.ly/2qmKbHk)

<p align="center">
  <img src="img/2.png" />
</p>

Компоненты трехзвенной архитектуры:

- клиент - этот компонент отвечает за представление данных конечному пользователю;
- выделенный сервер приложений - здесь содержится бизнес-логика приложения;
- сервер БД - предоставляет запрашиваемые данные.

**Сервер приложений** (**application server**) – сервисная программа, которая обеспечивает доступ клиентов к прикладным программам, выполняющимся на сервере.

Большинство серверов приложений имеют в своем составе веб-сервер. Это означает, что сервер приложений может делать все, на что способен веб-сервер. Кроме того, сервер приложений имеет компоненты и функции для поддержки сервисов уровня приложения, таких как пул соединений, поддержка транзакций и так далее.

> Информация о сервере приложений - http://bit.ly/2qt2Q4t. 
> Отличия веб-сервера и сервера приложений - http://bit.ly/2qlUaNe
> Подробнее про сервлеты и контейнеры сервлетов - http://bit.ly/2Q9GAaP

## Технология Java Servlet

На заре развития интернета не существовало технологий для создания динамических веб-страниц. В то время сайт представлял собой набор статических заранее написанных и сверстанных страниц с помощью языка разметки HTML. Если владелец сайта хотел обновить информацию на страничке, он делал это непосредственно на своем компьютере, после чего загружал на сервер обновленную версию HTML-страницы.

Среди предложенных решений по созданию динамических страниц, одной из первых была технология Java Servlet. В то время это была революционная технология, которая позволяла расширить возможности веб-серверов на основе модели запрос-ответ (request - response). Технология сервлетов позволяла веб-серверам обрабатывать HTTP-запросы и динамически генерировать веб-странички в зависимости от HTTP-запроса.

> На данный момент актуальной версией технологии является версия 5.0, спецификацию технологии смотрите [здесь](https://jakarta.ee/specifications/servlet/5.0/).

Несмотря на почтенный возраст, технология сервлетов претерпела серьезные изменения для того, чтобы соответствовать современной технологии разработки веб-приложений. На данный момент, технология сервлетов является наиболее часто используемой технологией для обработки HTTP запросов/откликов. Кроме того, сервлеты являются базой для почти всех Java-фреймворков, которые работают с HTTP протоколом (JSF, Struts, Spring MVC, BIRT и так далее).

**Сервлет** (Servlet), по сути, является классом Java, который используется для расширения возможностей сервером, предназначенных для размещения приложений. Сервлеты могут отвечать на запросы и генерировать отклики. Базовым классом для всех сервлетов является класс `javax.servlet.GenericServlet`. Этот класс определяет обобщенный, независимый от протокола сервлет.

Сервлеты являются базовыми элементами, на которых строится клиент-серверная архитектура.

Схема работы технологии сервлетов представлена на рисунке ниже

<p align="center">
  <img src="img/3.png" />
</p>

1. клиент (например, веб-браузер) передает HTTP-запрос веб-серверу. В случае, если от веб-сервера требуется предоставить статический файл или какой-то ресурс (например, изображение), то он просто возвращает требуемый статический файл или ресурс;
2. если веб-сервер не может самостоятельно обработать HTTP-запрос (например, пользователь передает какие-то данные либо требуется предоставить динамическую страницу и так далее), веб-сервер передает этот запрос web-контейнеру (его еще называют servlet-контейнером);
3. контейнер определяет – какой сервлет может выполнить этот запрос, создает объекты классов `HttpServletRequest` и `HttpServletResponse`, создает thread, создает объект класса сервлета и передает ему объекты классов `HttpServletRequest` и `HttpServletResponse`;
4. контейнер вызывает метод сервлета `service()`, который вызывает соответствующий HTTP-запросу метод (например, если запрос был HTTP GET, то будет вызван метод `doGet()`, подробнее этот вопрос будет разбираться далее), которому, в качестве аргументов, передает объекты классов `HttpServletRequest` и `HttpServletResponse`;
5. соответствующий метод (например, метод `doGet()`) возвращает динамическую страницу внутри объекта класса HttpServletResponse, ссылку на который имеет контейнер;
6. после этого поток завершается, контейнер конвертирует объект класса `HttpServletResponse` в HTTP-отклик (HTTP response) и отдает его веб-серверу, который возвращает его клиенту.

## Протокол HTTP

Протокол HTTP лежит в основе обмена данными в Интернете. HTTP является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим получателем (браузером или другим клиентским приложением).

Клиенты и серверы взаимодействуют, обмениваясь одиночными сообщениями (а не потоком данных). Сообщения, отправленные клиентом называются запросами, а сообщения, отправленные сервером, называются ответами.

HTTP - это клиент-серверный протокол, то есть запросы отправляются какой-то одной стороной - участником обмена (user-agent). Чаще всего в качестве участника выступает веб-браузер, но им может быть кто угодно.

Каждый **запрос** (request) отправляется серверу, который обрабатывает его и возвращает ответ (response).

**Участник обмена** (user agent) - это любой инструмент или устройство, действующее от лица пользователя.

На другой стороне коммуникационного канала расположен сервер, который обслуживает (serve) пользователя, предоставляя ему документы по запросу. С точки зрения конечного пользователя, сервер всегда является некой одной виртуальной машиной, полностью или частично генерирующий документ, хотя фактически он может быть группой серверов, между которыми балансируется нагрузка, то есть перераспределяются запросы различных пользователей, либо сложным программным обеспечением, опрашивающим другие компьютеры.

### HTTP-запросы (HTTP-request)

<p align="center">
  <img src="img/4.png" />
</p>

Запросы содержат следующие элементы:

- HTTP-метод, обычно глагол подобно `GET`, `POST` или существительное, как `OPTIONS` или `HEAD`, определяющее операцию, которую клиент хочет выполнить. Обычно, клиент хочет получить ресурс (используя `GET`) или передать значения HTML-формы (используя `POST`), хотя другие операции могут быть необходимы в других случаях;
- путь к ресурсу;
- заголовки (опционально), предоставляющие дополнительную информацию для сервера;
- для некоторых методов, таких как `POST`, тело метода, которое содержит отправленный ресурс.

### HTTP-ответы

Пример HTTP-ответа

<p align="center">
  <img src="img/5.png" />
</p>

Ответы содержат следующие элементы:

- версию HTTP-протокола;
- HTTP код состояния, сообщающий об успешности запроса или причине неудачи;
сообщение состояния - краткое описание кода состояния;
- опционально: тело, содержащее пересылаемый ресурс.

Код состояния - это трехзначное число, которое отдает сервер на запрос клиента и благодаря которому корректируется дальнейшая обработка запрашиваемого документа. За числом всегда идет краткое пояснение кода на английском языке, отделенное пробелом - первичная инструкция клиенту.

Классы состояния - группа кодов, объединенных определенными признаками. На класс состояния указывает первая цифра в коде.

Выделяют пять классов:

- `1ХХ` - информационные кода. Они отвечают за процесс передачи данных. Это временные коды, они информируют о том, что запрос принят и обработка будет продолжаться;
- `2ХХ` - успешная обработка. Запрос был получен и успешно обработан сервером;
- `3ХХ` - перенаправление (редирект). Эти ответы сервера гласят, что нужно предпринять дальнейшие действия для выполнения запроса. Например, сделать запрос по другому адресу;
- `4ХХ` - ошибка клиента. Это значит, что запрос не может быть выполнен на стороне клиента;
- `5ХХ` - ошибка сервера. Эти коды возникают из-за ошибок на стороне сервера. В данном случае клиент сделал все правильно, но сервер не может выполнить запрос.

Для кодов этого класса сервер обязательно показывает сообщение, что не может обработать запрос и по какой причине.

## Платформа Jakarta EE

Как язык программирования, в рамках одной версии Java везде приблизительно одинаковая. С точки зрения платформы, существуют разные вариации:

- Standard Edition (SE) - основной набор;
- Enterprise Edition (EE) - стандартная версия, с дополнительными интерфейсами корпоративных web-технологий;
- Micro Edition (ME) - для платформ, сильно ограниченных в ресурсах: Интернет Вещей, Raspberry Pi, умные телевизоры и так далее;
- Java Card - платформа для банковских и SIM-карт. Подмножество основного языка, с урезанной библиотекой, измененными байткодом и упором на безопасность;
- JavaFX - платформа для десктопных приложений, замена Swing.

Enterprise-версия Java изначально называлась J2EE, после Java 5, J2EE 1.5 превратилась в Java EE 5.

В 2018-ом компания Oracle рассталась с enterprise-версией, передала её open-source организации Eclipse Foundation, после чего Java EE была переименована в Jakarta EE.

Jakarta EE - это платформа, которая предлагает набор компонентов и API для разработки бизнес-приложений на Java. Она расширяет Java SE спецификациями для разработки и запуска масштабируемых, надежных и безопасных корпоративных приложений.

Jakarta EE - это, проще говоря, набор API и фреймворк для создания новых. Как таковая, эта платформа особенно актуальна для разработки бэкенда или серверной части.

### Создание тестового проекта на платформе Jakarta EE

Продемонстрируем использование технологии сервлетов на тестовом примере.

Для начала, загрузим и установим контейнер сервлетов Apache Tomcat.

> Актуальную 10ую версию Apache Tomcat можно скачать [здесь](https://tomcat.apache.org/download-10.cgi). Ищите Binary Distributions\Core.

При установке обязательно укажите путь к JRE, без него Apache Tomcat не будет работать.

После установки запустите приложение **Monitor Tomcat**. После этого, в трее вы увидите значок приложения. Нажмите на Start Service, после чего кнопка в трее должна стать зеленой.

<p align="center">
  <img src="img/6.png" />
</p>

Далее перейдем в браузере по адресу http://localhost:8080 (Apache Tomcat по умолчанию использует порт 8080, если вы указали другой порт при установке или в настройках - используйте его). Если установка и запуск прошел без ошибок, вы должны увидеть в браузере стартовую страницу Apache Tomcat

<p align="center">
  <img src="img/7.png" />
</p>

Далее откроем IntelliJ IDEA и создадим новый maven-проект, архетип не выбираем

<p align="center">
  <img src="img/8.png" />
</p>

После создания проекта, у вас будет открыт файл `pom.xml`.

POM (Project Object Model) является базовым модулем Maven. Это специальный XML-файл, который всегда хранится в базовой директории проекта.

Файл POM содержит информацию о проекте и различных деталях конфигурации, которые используются Maven для создания проекта.

Этот файл также содержит задачи и плагины. Во время выполнения задач, Maven ищет файл pom.xml в базовой директории проекта. Он читает его и получает необходимую информацию, после чего выполняет задачи.

Для того, чтобы иметь возможность работать с сервлетами, необходимо скачать и подключить библиотеку `jakarta.servlet`, которая содержит необходимые классы и аннотации.

Для этого отредактируем pom.xml следующим образом - добавим элемент `<dependencies>`, в котором указываем нужную библиотеку и версию. Итоговый pom-файл будет выглядеть следующим образом

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>ua.opu</groupId>
    <artifactId>hello_servlet</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            <groupId>jakarta.servlet</groupId>
            <artifactId>jakarta.servlet-api</artifactId>
            <version>5.0.0</version>
        </dependency>
    </dependencies>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
    </properties>

</project>
```

Для того, чтобы Maven загрузил библиотеки, нажмите правой кнопкой на область кода, выберите `Maven -> Reload Project`.

Далее, создадим файл `HelloServlet`, где напишем следующий код

```java
@WebServlet("/")
public class HelloServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        PrintWriter out = resp.getWriter();
        out.println("<h1>Hello! This is example!</h1>");
        out.close();
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doPost(req, resp);
    }
}
```

Обратите внимание на аннотацию `@WebServlet("/")`. Она указывает Apache Tomcat, что данный класс обрабатывает запросы с указанием корня в качестве пути.

Далее, нам необходимо скомпилировать данный проект и "упаковать" его в war-файл, для того, чтобы загрузить его в сервлет-контейнер.

WAR (Web application ARchive) файлы используются для распространения Java web-приложений. WAR имеет такую же структуру, как и JAR-файл, единый сжатый файл, содержащий несколько файлов внутри него.

WAR-файлы используются для объединения JSP-файлов, сервлетов, Java class-файлов, XML-файлов, javascript-библиотек, JAR-библиотек, статических web-страниц и любых других ресурсов, необходимых для работы приложения.

WAR-файлы обычно разворачивают в контейнерах сервлетов, но также возможно разворачивать и в Java EE серверах приложений. Когда WAR-файл разворачивается в контейнере, контейнер обычно распаковывает его для доступа к файлам, а затем запускает приложение. На основе контейнеров сервлетов получается наиболее производительная платформа для Java web-приложений, WAR-файлы являются не только стандартом Java спецификации, но WAR-файлы нельзя редактировать, пока работает приложение. Любые изменения потребуют пересборки файла.

Для получения war-файла необходимо указать, что используется формат сборки war, а также необходимо добавить плагин `maven-war-plugin`, который осуществляет упаковку проекта. Всё это добавляется в pom-файл, который будет иметь следующий вид

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>ua.opu</groupId>
    <artifactId>hello_servlet</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>war</packaging> <!-- Тип упаковки -->

    <dependencies>
        <dependency>
            <groupId>jakarta.servlet</groupId>
            <artifactId>jakarta.servlet-api</artifactId>
            <version>5.0.0</version>
        </dependency>
    </dependencies>

    <!-- Плагин для получения war-файла -->
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-war-plugin</artifactId>
                <version>3.3.2</version>
            </plugin>
        </plugins>
    </build>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
    </properties>
</project>
```

После этого необходимо выбрать панель Maven справа и выбрать `Lifecycle->clean`, после чего выбрать `Lifecycle->package`.

Если всё прошло успешно, в директории `target` появится файл с расширением war.

Таким образом, мы получили архив с сервлетом и теперь его необходимо добавить в контейнер сервлетов.

Это можно сделать несколькими способами. Во-первых, можно просто поместить war-файл в директорию `путь_к_tomcat\webapps`

В этом случае, путь к приложению будет иметь вид `хост:порт/имя_файла_сервлета`

Можно добавить контейнер через Manager App по адресу `http://хост_tomcat:порт/manager/html`, где можно указать свой путь к приложению.

Проверим работу созданного сервлета

<p align="center">
  <img src="img/9.png" />
</p>

## Веб-сервисы

Всемирная паутина является готовой платформой для создания и использования распределенных систем на основе веб-служб. Веб-сервер выступает в качестве сервера приложений, к которым обращаются не конечные пользователи, а сторонние приложения. Это позволяет многократно использовать функциональные элементы, устранить дублирование кода, упростить решение задач интеграции приложений.

**Веб-служба** или **веб-сервис** (web-service) – сетевая технология, обеспечивающая межпрограммное взаимодействие на основе веб-стандартов. W3C определяет веб-службу как «программную систему, разработанную для поддержки интероперабельного межкомпьютерного (machine-to-machine) взаимодействия через сеть».

<p align="center">
  <img src="img/10.png" />
</p>

К моменту появления веб-служб уже существовали технологии, позволяющие приложениям взаимодействовать на расстоянии, где одна программа могла вызвать какой-нибудь другой метод в другой программе, которая при этом могла быть запущена на компьютере, расположенном в другом городе или даже стране. Это сокращенно называется RPC (Remote Procedure Calling – удаленный вызов процедур). В качестве примеров можно привести технологии CORBA, а для Java – RMI (Remote Method Invoking – удаленный вызов методов).

Идея веб-службы заключалась в создании такого RPC, который будет упаковываться в HTTP пакеты. Такой подход стал очень популярным, т.к. HTTP был хорошо известен, прост, понятен и обеспечивал лучшее «прохождение» через различные firewall`ы. Именно с появлением веб-сервисов развилась идея SOA – сервис-ориентированной архитектуры веб-приложений (Service Oriented Architecture).

API (интерфейсы прикладного программирования) предоставляют правила и определения, которые позволяют приложениям обмениваться данными и взаимодействовать друг с другом. API определяет типы вызовов и запросов, которые одно приложение может отправлять другому, как выполнять эти запросы, используемые форматы данных и соглашения, которым должны следовать клиенты.

API-интерфейсы также поддерживают «подключаемость» приложений, которые образуют более крупную систему, поскольку они позволяют двум приложениям - даже если они написаны на разных языках программирования и работают на разных платформах - общаться и взаимодействовать друг с другом.

### API-интерфейсы веб-сервисов

На сегодняшний день наибольшее распространение получили следующие протоколы реализации API:

- **SOAP** (Simple Object Access Protocol) – тройка стандартов SOAP/WSDL/UDDI. Сообщения упаковываются в виде структуры, которая называется конверт (envelope), которая включает идентификатор сообщения, заголовок и тело сообщения;
- **REST** (Representational State Transfer) – архитектурны стиль, который использует концепцию ресурсов и определяет операции через методы HTTP-протокола;
- **XML-RPC** (XML Remote Procedure Call) – вызов удаленных процедур, использующий XML для кодирования своих сообщений и HTTP в качестве транспортного механизма;
- **gRPC** (удаленный вызов процедур Google) – это архитектура RPC с открытым исходным кодом, разработанная Google для обеспечения высокоскоростной связи между микросервисами. gRPC позволяет разработчикам интегрировать сервисы, написанные на разных языках.

### Протокол REST

**Передача состояния представления** (Representational State Transfer (**REST**)) является архитектурным стилем, в котором веб-службы рассматриваются, как ресурсы и могут быть идентифицированы Унифицированными идентификаторами ресурсов (Uniform Resource Identifiers (URI)).

Веб-службы, разработанные в стиле REST и с учетом ограничений REST, известны как RESTful веб-службы.

Каждая единица информации в REST называется ресурсом и имеет однозначный URI, который является ее, своего рода, первичным ключом. То есть, например, третья книга с книжной полки будет иметь URI `/book/3`, а 35ая страница в этой книге – `/book/3/page/35/`. Отсюда и получается строго заданный формат. Причем совершенно не имеет значения, в каком формате находятся данные по адресу `/book/3/page/35/` – это может быть и HTML, и отсканированная копия книги в виде jpeg-файла и документ Microsoft Word.

Над ресурсами выполняется ряд простых четко определенных операций. В качестве протокола передачи данных используется stateless-протокол, обычно HTTP.

При использовании протокола HTTP действия над данными выполняются с помощью HTTP-методов: `GET` (получить), `PUT` (добавить, заменить), `POST` (добавить, изменить, удалить), `DELETE` (удалить). Таким образом, действия CRUD (Create-Read-Update-Delete) могут выполняться как со всеми 4-мя методами, так и только с помощью `GET` и `POST`. Примеры запросов:

- `GET /book/` – получить список всех книг;
- `GET /book/3` – получить книгу номер 3;
- `PUT /book/` – добавить книгу (данные в теле запроса);
- `POST /book/3` – изменить книгу (данные в теле запроса);
- `DELETE /book/3` – удалить книгу.

Как правило, необязательно поддерживать все методы, но, как правило, веб-служба должна поддерживать:

- `GET` – используется для получения существующих ресурсов;
- `POST` – используется для создания/обновления нового ресурса;
- `PUT` – используется для обновления/замены ресурса;
- `DELETE` – используется для удаления ресурса.

Кроме этого, служба может поддерживать такие методы как `PATCH` (обновление части ресурса), `HEAD` (возвращение заголовка ресурса, т.е. метаданных) и т.д.
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
# Быстрое создание приложения с помощью Spring Boot. Архитектура Spring-приложения (web layer, service layer, repository layer)

## Фреймворк Spring

Spring – свободно-распространяемый легковесный фреймворк, призванный упростить разработку корпоративных и веб-приложений (можно использовать и для любых других типов приложений) на языке Java (является альтернативной стеку Jakarta EE).

<p align="center">
  <img src="img/11.png" />
</p>

В данный момент Spring представляет собой целый набор модулей, которые можно использовать выборочно для тех или иных проектов.

<p align="center">
  <img src="img/12.png" />
</p>

Дадим краткую характеристику некоторым модулям Spring:

- Spring Core – ядро платформы, предоставляет базовые средства для создания приложений — управление компонентами (бинами, beans), внедрение зависимостей, MVC фреймворк, транзакции, базовый доступ к БД. В основном это низкоуровневые компоненты и абстракции. По сути, неявно используется всеми другими компонентами;
- Spring MVC – обеспечивает архитектуру паттерна Model-View-Controller при помощи слабо связанных готовых компонентов для разработки веб-приложений;
- Spring Data – обеспечивает доступ к данным: реляционные и нереляционные БД, KV хранилища и т.п.;
- Spring Cloud – используется для микросервисной архитектуры;
- Spring Security – авторизация и аутентификация, доступ к данным, методам и т.п. OAuth, LDAP, и различные провайдеры.

### Spring Boot

Проект Spring Boot – решение, которое позволяет вам легко создавать полноценные приложения Spring, про которые можно сказать «просто запусти».

Spring Boot позволяет быстро создать и сконфигурировать (т.е. настроить зависимости между компонентами) приложение, упаковать его в исполняемый самодостаточный артефакт. Это то связующее звено, которое объединяет вместе набор компонентов в готовое приложение.

Особенности Spring Boot:

- создание полноценных Spring-приложений;
- встроенный сервлет-контейнер (Tomcat или Jetty);
- обеспечивает начальные pom-файлы для упрощения конфигурации Maven;
- используется автоконфигурация, где это возможно;
- используется принцип «convention over configuration». Для большинства конфигураций не нужно ничего настраивать.

Изучение фреймворка Spring лучше всего начать с установки требуемого программного обеспечения и разработки тестового приложения с помощью Spring Boot.

Создание Spring Boot проекта

Существует несколько способов создать Spring Boot проект. Из наиболее простых способов можно выделить:

- генерация готового проекта на сайте `https://start.spring.io/` (проект Spring Initializr);
- создание проекта средствами IDE.

Создадим проект с помощью генерации проекта на сайте.

Заходим на сайт https://start.spring.io/, указываем сборщик, язык, версию Spring Boot, а также мета-данные проекта

<p align="center">
  <img src="img/13.png" />
</p>

Далее необходимо нажать кнопку **Add Dependencies**, после чего откроется окно с модулями

<p align="center">
  <img src="img/14.png" />
</p>

выбирайте пункт Spring Web

<p align="center">
  <img src="img/15.png" />
</p>

Нажимайте кнопку **Generate**, после чего будет загружен архив с проектом.

После этого необходимо зайти в IntelliJ IDEA, разархивировать проект и открыть папку с проектом.

Рассмотрим ключевые файлы проекта:

- `SpringbootexampleApplication.java` - стартовый класс Spring Boot приложения;
- `application.properties` - файл с настройками приложения. В нем можно переопределить настройки по умолчанию;
- `pom.xml` - POM-файл проекта. Используется сборщиком Maven.

Еще раз напомним, что **POM-файл** (Project Object Model) – это XML-файл, который содержит информацию о деталях проекта, и конфигурации для создания проекта на Maven. Он всегда находится в базовом каталоге проекта. Во время выполнения задач, Maven ищет pom-файл в базовой директории проекта. Он читает его и получает необходимую информацию, после чего выполняет задачи.

Корневым элементом является элемент `<project>`. Внутри тега `project` содержится основная и обязательная информация о проекте.

**Зависимости** (**dependencies**) – это те библиотеки, которые непосредственно используются в проекте для компиляции кода или его тестирования.

Мы создаем RESTful веб-службу с помощью Spring Boot, поэтому нам нужно «подтянуть» для нашего проекта различные Spring-модули (библиотеки с классами, jar-файлы).

В обычных проектах нам бы было необходимо добавлять каждую зависимость вручную, но Spring Boot позаботился о нас и предоставил нам своего рода «мета-зависимости». Смысл их в том, что Spring Boot понимает, что если вы создаете web-приложение то вам нужен примерно одинаковый набор jar-файлов, поэтому чтобы не писать каждый jar-файл отдельно, мы указываем одну зависимость, а она уже «подтянет» за нас другие отдельные зависимости для создания веб-приложения.

Запустим приложение

<p align="center">
  <img src="img/16.png" />
</p>

зайдем в браузер и попробуем зайти на сайт.

<p align="center">
  <img src="img/17.png" />
</p>

Веб-сервер был запущен успешно.

Как видите, Spring Boot приложение успешно запущено. Так как Spring Boot берет на себя большую часть рутинной работы по созданию и запуску приложения, давайте разберемся, что же происходит, когда мы запускаем приложение:

1. устанавливается конфигурация приложения по умолчанию;
2. запускается контекст приложения Spring (Spring application context) – это контейнер для кода, который работает на сервере (службы, контроллеры и т.д.). Все приложения Spring имеют этот контекст, который запускается при запуске приложения. Spring Boot создает этот контекст при запуске приложения;
3. выполняется сканирование пути к классам (class path scan). Чтобы добавить код в Spring Boot, необходимо создать свои классы и аннотировать их определенным образом. Например, если вы хотите добавить контроллер, вы создаете класс и аннотируете его с помощью аннотации `@Controller` и так далее. То есть, вы как бы помечаете ваши классы, что это контроллер, это сервис, это еще что-то. Spring сканирует эти классы и, в зависимости от нашего маркера, он работает с этими классами по-разному. То есть Spring сканирует ваш код и ищет классы с этими аннотациями (помимо маркеров, обычно в аннотациях содержатся другие метаданные, которые дают уточняющую информацию для Spring);
4. запускается Tomcat-сервер. Мы как раз зашли на сервер через URL и получили страницу с ошибкой, так как на сервере не был предусмотрен обработчик запроса с таким URL. Мы не скачивали Tomcat и не устанавливали его – все за нас сделал Spring Boot.

## Структура enterprise-приложения Spring

Простое приложение Spring имеет трехслойную структуру:

- Web layer – верхний слой приложения. Он отвечает за обработку ввода пользователя и возврат корректного ответа. Также веб-слой отвечает за обработку исключений, которые могут выбрасываться в других слоях приложения. Так как веб-слой является точкой входа в приложение, он также отвечает за аутентификацию и является первой линией защиты приложения;
- Service layer – слой сервисов, находится ниже веб-слоя. Этот слой содержит сервисы приложения и инфраструктуры. Сервисы приложения предоставляют публичный API сервисного слоя. Они также отвечают за транзакции и авторизацию. Инфраструктурные сервисы содержат код для взаимодействия с внешними ресурсами, такими как файловая система, базы данных, почтовые сервера и так далее. Часто эти сервисы используются несколькими сервисами приложения;
- Repository layer – самый нижний слой приложения. Он отвечает за взаимодействие с используемыми хранилищами данных.

<p align="center">
  <img src="img/18.png" />
</p>

## Разработка web-слоя

Для обработки запросов и возврата данных необходимо предусмотреть соответствующие контроллеры REST-запросов, которые и будут составлять наш веб-слой.

Контроллер – это java-класс, методы которого призваны обрабатывать HTTP-запросы. Отличие обычного контроллера от REST-контроллера заключается в том, что в REST-контроллере каждый метод класса возвращает данные вместо представления. Рассмотрим пример простого REST-контроллера. Создадим в проекте пакет `controllers`, внутри которого создадим класс `HelloController`.

```java
@RestController
public class HelloController {}
```

Обратите внимание, что мы пометили класс аннотацией `@RestController`. Таким образом, мы даем знать Spring, что это не просто класс, а контроллер REST-запросов. В классе создадим метод, который будет возвращать строку.

```java
@RestController
public class HelloController {
    
    public String hello() {
        return "hello";
    }
}
```

Говорят, что методы контроллера «отображаются» на HTTP-запросы. Это значит, что при поступлении определенного HTTP-запроса (с определенным URL и HTTP-методом), будет вызван определенный метод контроллера, который вернет некоторые данные. Этим данные будут упакованы в HTTP-ответ и высланы обратно клиенту.

Нам необходимо сделать так, чтобы наш созданный метод был вызван, когда на сервер поступит HTTP-запрос с определенным URL, например `http://localhost:8080/hello`. Для этого необходимо пометить метод аннотацией `@GetMapping` c параметром `(“/hello”)` – часть URL, на который будет отображаться данный метод.

```java
@RestController
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "hello";
    }
}
```

**Для каждого из четырех основных HTTP-метода предусмотрена своя аннотация (`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`). Метод, помеченный определенной аннотацией, обрабатывает запросы только с определенным HTTP-методом.**

Запустим сервер, заходим на `http://localhost:8080/hello` и видим строку с ответом.

<p align="center">
  <img src="img/19.png" />
</p>

Что произошло? Строка «hello» была помещена в тело HTTP-ответа, браузер получил text/plain с содержимым «hello» и просто вывел его на экран.

### Передача параметров в REST-запросах

Очень часто клиенту необходимо вместе с запросом передать некоторые параметры запроса, которые уточняют и конкретизируют запрос.

Параметры запроса можно передать несколькими способами. Рассмотрим следующие способы:

- указание параметра в URL-пути (`localhost:8080/rooms/256`);
- указание параметра в строке запроса, которая идет после URL-пути и отделяется символом `?` `(localhost:8080/rooms?id=256&param2=value2`);
- передача параметров в теле запроса (часто используется для передачи заполненной пользователем формы или передачи данных в формате JSON).

Рассмотрим, каким образом можно получить и обработать параметры запроса, переданные тем или иным способом.

#### Указание параметра в URL-пути

При создании метода-конечной точки (endpoint), в аннотации необходимо указать вариативную часть и назначить ей идентификатор

```java
@GetMapping("/room/{id}")
public void getRoomById() {}
```

Далее необходимо предусмотреть входной аргумент метода, куда Spring запишет значение вариативной части и указать аннотацию `@PathVariable` для этой переменной. Также необходимо указать идентификатор, который вы указали в аннотации `@GetMapping`.

```java
@GetMapping("/room/{id}")
public void getRoomById(@PathVariable(value = "id") int roomId) {
    // ...
}
```

В рамках одного запроса может быть несколько вариативных частей, которые можно считать и обработать

```java
@GetMapping("/room/{id1}/{id2}")
public void getRoomById(@PathVariable(value = "id1") int blockId, @PathVariable(value = "id2") int roomId) {
    // ...
}
```

#### Указание параметра в строке запроса

В этом случае, для каждого параметра запроса создается входной аргумент, указывается аннотация `@RequestParam`, а также указывается имя параметра.

```java
// запрос: http://localhost:8080/room?room_id=250&block_id=10
@GetMapping("/room")
public void getRoomById(@RequestParam(value = "room_id") int roomId, @RequestParam(value = "block_id") int blockId) {
    // ...
}
```

#### Передача параметров в теле запроса

Если в качестве клиента выступает браузер пользователя, данные от клиента на сервер передаются в виде полей формы, которые заполняет пользователь браузера. В этом случае параметры передаются в теле запроса с помощью метода `POST`.
Форма может иметь следующие MIME-типы:

- `application/x-www-form-urlencoded`: значения кодируются в кортежах с ключом, разделенных символом '&', с '=' между ключом и значением. Не буквенно-цифровые символы - percent encoded: это причина, по которой этот тип не подходит для использования с двоичными данными (вместо этого используйте `multipart/form-data`);
- `multipart/form-data`: каждое значение посылается как блок данных ("body part"), с заданными пользовательским клиентом разделителем ("boundary"), разделяющим каждую часть. Эти ключи даются в заголовки `Content-Disposition` каждой части `text/plain`.

Для обработки данных формы необходимо создать входной аргумент для каждого параметра, для каждого входного аргумента указать аннотацию `@RequestParam`, а также имя параметра.

```java
@PostMapping("/book")
public void bookRoom(@RequestParam(value = "room_id") int room_id,
                     @RequestParam(value = "firstname") String firstname,
                     @RequestParam(value = "lastname") String lastname,
                     @RequestParam(value = "days") int days) {
    // ...
}
```

**Существует несколько более простых способов получения данных формы, но в данном курсе они не рассматриваются. Вышеуказанный способ является самым простым и понятным на данном этапе изучения курса.**

### Передача данных между клиентом и сервером

Так как язык Java является ОО языком, нам было бы удобно работать с входящими и исходящими данными в объектном виде - было бы здорово, если бы REST-контроллер возвращал бы данные в виде объекта некоторого класса, а не в виде набора полей со значениями. Также было бы здорово, чтобы мы могли просто возвращать клиенту объект или коллекцию объектов некоторых классов без необходимости формировать Map из полей и значений.

Для реализации этого функционала, в Spring используется механизм **сериализации** и **десериализации**.

**Сериализация** - это преобразование объекта в последовательность байтов, так что объект можно легко сохранить в постоянное хранилище или передать по каналу связи. Затем поток байтов можно **десериализовать** - преобразовать в реплику исходного объекта.

Язык Java предоставляет стандартный механизм Java Serialization API для создания сериализуемых объектов, однако, он нам не подходит, так как ограничивает возможности для использования различных языков и технологий на стороне клиента и сервера.

Мы можем использовать сторонние библиотеки для сериализации объекта с помощью формата XML или JSON.

Использование формата JSON (http://bit.ly/32ZelBq) является более предпочтительным. Для сериализации и десериализации в Spring по-умолчанию используется библиотека Jackson.

**Библиотека Jackson позволяет гибко настроить процесс сериализаци и десериализации, однако, в рамках данного курса мы будем использовать стандартные механизмы сериализации и десериализации, чтобы уделять этому процессу как можно меньше внимания.**

Рассмотрим ситуацию, когда нам необходимо вернуть клиенту данные в объектном виде. Создадим класс с несколькими полями, создадим объект и вернем его в качестве результата GET-запроса.

```java
public class Room {
    private Integer id;
    private String roomInfo;
    private Integer roomCapacity;
    private double price;

    public Room(Integer id, String roomInfo, Integer roomCapacity, double price) {
        this.id = id;
        this.roomInfo = roomInfo;
        this.roomCapacity = roomCapacity;
        this.price = price;
    }
    // геттеры и сеттеры
}

@GetMapping("/roominfo")
public Room getRoomInfoById(@RequestParam(value = "room_id") int roomId) {
    return new Room(roomId, "Отличная комната!", 2, 200);
}
```

**Обратите внимание, что в код класса Room не зря были включены геттеры и сеттеры. Их наличие обязательно для сериализации и десериализации!**

Используем Postman для эмуляции клиента, сделаем GET-запрос и получим следующий результат

<p align="center">
  <img src="img/20.png" />
</p>

Как мы видим, поля объекта были сериализованы с помощью формата JSON. Теперь клиент, после получения этих данных, сможет с помощью процесса десериализации получить объект и удобно работать с ним.

Теперь рассмотрим обратную ситуацию. Клиент делает POST-запрос и передает в теле запроса данные о новом студенте.

<p align="center">
  <img src="img/21.png" />
</p>

На стороне сервера создаем класс `Student` с соответствующими полями.

```java
public class Student {

    private String firstname;
    private String lastname;
    private String phone;
    private int age;

    public Student(String firstname, String lastname, String phone, int age) {
        this.firstname = firstname;
        this.lastname = lastname;
        this.phone = phone;
        this.age = age;
    }

    // геттеры и сеттеры

    @Override
    public String toString() {
        return "Student{" +
                "firstname='" + firstname + '\'' +
                ", lastname='" + lastname + '\'' +
                ", phone='" + phone + '\'' +
                ", age=" + age +
                '}';
    }
}
```

Создаем конечную точку для обработки запроса. Обратите внимание, что мы используем аннотацию `@RequestBody`.

```java
@PostMapping("/student")
public void addStudent(@RequestBody Student student) {
    System.out.println(student);
}
```

Конфигурация HTTP-response с помощью класса `ResponseEntity`

Далеко не всегда ответ сервера состоит в возврате какого-то значения или какого-то объекта. Очень часто необходимо вернуть ответ с определенным HTTP-кодом и сообщением об ошибке, указать определенный заголовок и так далее.

В этом случае необходимо использовать класс `ResponseEntity`. Класс `ResponseEntity` является оберткой для ответа и дополнительно для HTTP заголовков и кода статуса. Он является обобщенным, что позволяет использовать любой тип в качестве тела ответа.

```java
@GetMapping("/student")
public ResponseEntity<?> getStudentById(@RequestParam(value = "id") int studentId) {
    if (studentId < 1) {
        return ResponseEntity.badRequest().body("Invalid id");
    } else {
        return ResponseEntity.ok(new Student("Ivan", "Ivanov", "223322", 20));
    }
}
```

Подробную информацию по поводу `ResponseEntity` читайте здесь - `https://www.baeldung.com/spring-response-entity`
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
# Интеграция с СУБД. Технология ORM. Фреймворк Hibernate

В Spring имеется набор модулей для интеграции с различными технологиями хранения данных. Spring позволяет избавить разработчика от рутины при разработке программного кода, реализующего доступ к данным. Вместо возни с низкоуровневым доступом к данным можно положиться на Spring, который выполнит эту работу за вас, и сконцентрироваться на управлении данными в самом приложении.

## Что такое JDBC, драйвер, JPA, ORM и как это все между собой соотносится?

Как правило, каждая система управления базами данных (MySQL, PostgreSQL и так далее) имеет свой протокол взаимодействия с клиентами. Чтобы работать с базой данных, клиент должен соблюдать протокол взаимодействия с базой данных.

Чтобы программист не тратил время на самостоятельную реализацию протокола при разработке очередного приложения, разработчик сервера баз данных сам предоставляет всем желающим программный код, который общается с базой данных на понятном этой базе протоколе. Такой программный код и называется драйвером базы данных. Драйвер реализует протокол общения с БД и предоставляет API, которое позволяет нам общаться с базой данных, не вдаваясь в детали реализации протокола.

Как раз для этого разработчики Java предоставили стандарт **JDBC** (**Java DataBase Connectivity**) – специальное API, которое используется приложениями Java для взаимодействия с базой данных. Стандарт JDBC позволяет отправлять запросы к базе данных для выполнения операций выбора, вставки, обновления и удаления.

Если разработчики СУБД хотят, чтобы их база данных использовалась Java-разработчиками, они предоставляют JDBC-драйвер для их базы данных. Разработчики Java подключат драйвер и используют его для общения с той или иной базой данных. Если, в какой-то момент, разработчики захотят сменить СУБД, они просто меняют драйвер старой базы на драйвер новой. Благодаря стандарту JDBC, ничего менять в коде работы с базой данных не требуется.

### Что такое и зачем нужна технология ORM?

При написании объектно-ориентированного кода, который взаимодействует с базой данных, у разработчика возникает несколько проблем:

- данные в программе и в базе данных используют разные парадигмы (объектно-ориентированная и реляционная соответственно). Работу по преобразованию данных из одной парадигмы в другую ложатся на плечи программиста, что влечет за собой лишнюю работу и может приводить к ошибкам в процессе преобразования;
- программисту желательно абстрагироваться от конкретной схемы хранения данных. То есть, программисту желательно работать не с реляционной базой данных, а просто с некоторым «хранилищем», а конкретная реализация этого «хранилища» может быстро и безболезненно меняться.

 Для устранения этих проблем используется технология **ORM** (**Object-Relational Mapping**, «объектно-реляционное отображение») — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных».

<p align="center">
  <img src="img/img_1.jpg" />
</p>

Проще говоря, ORM – это прослойка, посредник между базой данных и объектным кодом. Используя ORM, программист не занимается формированием SQL-запросов и не думает в терминах «таблица», «записи» и «реляционные отношения», а просто работает с «хранилищем объектов» – он может туда записывать и получать объекты, не заботясь о подробностях их хранения.

В Java предусмотрен специальный стандарт **JPA** (**Java Persistence API**), который использует концепцию ORM. Существует несколько реализаций этого интерфейса, например, Hibernate, OpenJPA, EclipseLink и другие.

**Spring Data JPA** – обертка над JPA в Spring, которая предоставляет много полезных «фишек» разработчику. Она позволяет легче создавать Spring-управляемые приложения, которые используют новые способы доступа к данным, например нереляционные базы данных, map-reduce фреймворки, cloud сервисы, а так же уже хорошо улучшенную поддержку реляционных баз данных.

### Терминология JPA

Основное понятие JPA – сущность (Entity). Сущность – это Java-класс, который представляет бизнес-логику приложения и определяет данные, которые будут храниться в базе данных и извлекаться из нее.

Как правило, класс сущности представляет таблицу в базе данных, поля или свойства класса представляют собой колонки в таблице, а объект сущности представляет собой одну запись в таблице.

Важным моментом при работе с JPA являются аннотации, коих здесь будет очень много. Разберемся с некоторыми из них:

`@Entity` – позволяет серверу узнать, что это не просто какой-то класс, а сущность;
`@Id` – помечает первичный ключ в таблице. Вопрос составных ключей в данном занятии не рассматривается;
`@Table` – позволяет настраивать отображение класса в таблицу. В данном случае, мы можем указать, какое имя будет иметь соответствующая таблица в базе данных;
`@GeneratedValue` – указывает, что данное поле является генерируемым значением. Очень часто этой аннотацией помечают первичные ключи, чтобы они генерировались автоматически при добавлении новых записей в таблицу;
`@Column` – позволяет настраивать отображение колонки в таблице. В данном случае, мы можем указать, какое имя будет иметь соответствующая колонка в таблицу.

**Репозитории**. Главными компонентами для взаимодействий с БД в Spring Data являются репозитории. Каждый репозиторий работает со своим классом-сущностью.

В большинстве случаев, структура запросов к репозиторию будет одинаковая: «получить все записи», «получить записи, где столбец равен определенному значению» и так далее.

Spring Data JPA позволяет вам избежать рутинного создания запросов. Для этого вместо класса создадим интерфейс, который будет наследоваться от стандартного generic-интерфейса. Первый параметр означает тип класса-сущности, второй параметр – тип первичного ключа.

## Создание проекта и его интеграция с СУБД

Установим СУБД Postgres и запустим pgAdmin 4.

Создадим пользователя, после чего создадим базу данных для нашего приложения.

<p align="center">
  <img src="img/22.png" />
</p>

Добавляем в `pom.xml` зависимости для работы с Spring Data JPA и JDBC драйвер для Postgres.

```xml
<dependencies>

    ...
    
    <!-- jpa, crud repository -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <!-- PostgreSQL -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
    </dependency>
</dependencies>
```

Далее необходимо настроить подключение к СУБД и нужной базе данных.

Для настройки приложения Spring воспользуемся языком YAML. Для этого удалим файл `resources/application.properties` и создадим вместо него файл `application.yml`.

```xml
spring:
  jpa:
    database: POSTGRESQL
    show-sql: true
    hibernate:
      ddl-auto: create-drop
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  datasource:
    platform: postgres
    url: jdbc:postgresql://localhost:5432/ejournal
    username: ejournal_user
    password: 123456
    driverClassName: org.postgresql.Driver
```

Создадим класс сущности `Student`

```java
@Entity
@Table(name = "students")
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "last_name")
    private String lastName;

    private int age;
}
```

Для уменьшения количества кода, мы будем использовать плагин `Lombok`.

Проект Lombok — это плагин компилятора, который добавляет в Java новые «ключевые слова» и превращает аннотации в Java-код, уменьшая усилия на разработку и обеспечивая некоторую дополнительную функциональность.

Lombok преобразует аннотации в исходном коде в Java-операторы до того, как компилятор их обработает: зависимость lombok отсутствует в рантайме, поэтому использование плагина не увеличит размер сборки.

При использовании Lombok наш исходный код не будет валидным кодом Java. Поэтому потребуется установить плагин для IDE, иначе среда разработки не поймёт, с чем имеет дело. Lombok поддерживает все основные Java IDE. Интеграция бесшовная. Все функции вроде «показать использования» и «перейти к реализации» продолжают работать как и раньше, перемещая вас к соответствующему полю/классу.

<p align="center">
  <img src="img/23.png" />
</p>

Далее подключим библиотеку в `pom.xml`.

```xml
<dependencies>

    ...

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

Вернемся в класс `Student`, добавим аннотацию для геттеров, сеттеров, а также конструктор со всеми параметрами.

```java
@Entity
@Table(name = "students")
@Data
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "last_name")
    private String lastName;

    private int age;
}
```

### Программирование слоя сервисов

`Service` – это Java класс, который содержит в себе основную бизнес-логику. В основном сервис использует готовые DAO/Repositories или же другие сервисы, для того чтобы предоставить конечные данные для пользовательского интерфейса. Сервисы, как правило, вызываются контроллерами или другими сервисами.

```java
@org.springframework.stereotype.Service
public class Service {

    public void addStudent(Student student, int id) {
        // Добавление нового студента
    }

    public List<Student> getAllStudents() {
        // Получение списка студентов
    }
}
```

Объект службы создается контейнером Spring, каждая служба является «одиночкой» (синглтоном), который создается в момент запуска приложения и уничтожается в момент закрытия приложения. Обратите внимание на аннотацию `@Service`. Этой аннотацией мы сообщаем контейнеру Spring, что это не просто класс, а класс сервиса.

Итак, мы создали службу, у которой есть два публичных метода. Первый метод добавляет нового студента, второй метод возвращает список всех студентов. В дальнейшем служба будет обращаться к объекту репозитория за данными, а пока что оставим код таким, какой он есть.

Вернемся к созданию веб-слоя. Создадим класс контроллера, создадим две конечные точки: для добавления студента и для получения списка всех студентов.

```java
@RestController
public class Controller {

    @Autowired
    private Service service;

    @PostMapping("/student")
    public void addStudent(@RequestBody Student student) {
        service.addStudent(student);
    }

    @GetMapping("/student")
    public List<Student> getAllStudents() {
        return service.getAllStudents();
    }
}
```

Обратите внимание, что мы не создаем объект службы, а получаем его «извне» с помощью аннотации `@Autowired`. Контейнер Spring «внедрит» ссылку на объект службы в поле `service`.

```java
@Entity
@Table(name = "groups")
@Data
public class Group {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;
    private String name;

    @OneToMany(mappedBy = "group")
    private List<Student> studentList;
}
```

### Работа с репозиторием

Главными компонентами для взаимодействий с БД в Spring Data являются репозитории. Каждый репозиторий работает со своим классом-сущностью.

В большинстве случаев, структура запросов к репозиторию будет одинаковая: «получить все записи», «получить записи, где столбец равен определенному значению» и так далее.

Spring Data JPA позволяет вам избежать рутинного создания запросов. Для этого вместо класса создадим интерфейс, который будет наследоваться от стандартного generic-интерфейса. Первый параметр означает тип класса-сущности, второй параметр – тип первичного ключа.

```java
public interface StudentRepository extends JpaRepository<Student, Integer> {
}
```

Теперь перейдем в класс службы и создадим ссылку на объект репозитория.

```java
@org.springframework.stereotype.Service
public class Service {

    @Autowired
    private StudentRepository studentRepo;

    public void addStudent(Student student) {
        studentRepo.save(student);
    }

    public List<Student> getAllStudents() {
        return studentRepo.findAll();
    }
}
```

Обратите внимание, что мы не создавали класс, который реализует интерфейс `StudentRepository`, тогда откуда мы его получим объект интерфейсного типа?

Дело в том, что Spring сгенерирует класс за нас. Этот сгенерированный класс будет иметь набор стандартных операций для работы с сущностями. В нашем случае, это операция `findAll()`, которая возвращает все сущности в таблице `student`.

Запустим сервер и выполним два клиентских запроса - один на создание студента, второй - на получение списка всех студентов.

Добавляем нового студента

<p align="center">
  <img src="img/24.png" />
</p>

Теперь получим список всех студентов.

<p align="center">
  <img src="img/25.png" />
</p>

### Реализация отношения "один-ко-многим"

Как мы знаем, важной составляющей реляционных баз данных является отношения между таблицами "один-к-одному", "один-ко-многим", "многие-ко-многим".

Реализуем отношение "один-ко-многим". Создадим сущность `Group` - студенческая группа. В студенческой группе может быть от 0 до N студентов.

Прежде всего перейдем в сущность `Student`. Добавим поле `group`, который будет ссылаться на студенческую группу, в которой будет состоять студент. Так как в группе может быть много студентов, указываем аннотацию `@ManyToOne`. Также указываем аннотацию `@JoinColumn`, которая указывает на имя колонки, которая будет содержать Foreign Key.

**Технология ORM позволяет создавать двусторонние связи между таблицами. В этом случае, при выдаче JSON, может возникнуть бесконечный цикл. Чтобы его избежать, укажем аннотацию `@JsonIgnore`. В этом случае, колонка group будет проигнорирована в процессе сериализации\десериализации.**

```java
@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    private String firstname;
    private String lastname;
    private int age;

    @ManyToOne (fetch = FetchType.LAZY,optional = false)
    @JoinColumn(name = "group_id",nullable = false)
    @JsonIgnore
    private Group group;
}
```

Далее создадим сущность `Group`.

```java
@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "groups")
public class Group {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    private String name;

    @OneToMany(mappedBy = "group", cascade = CascadeType.ALL)
    private List<Student> students;

    public void addStudent(Student student) {
        students.add(student);
    }
}
```

Обратите внимание, что отношение один-ко-многим мы моделируем с помощью обычной коллекции. Указываем аннотацию `@OneToMany`, также в свойстве mappedBy указываем, какое поле "держит" отношение со стороны студента.

Далее модифицируем класс контроллера. Создадим конечные точки для добавления новой группы, а также для получения списка всех групп. Также модифицируем конечную точку для добавления студента, чтобы указать id группы, в которую необходимо добавить студента.

```java
@RestController
public class Controller {

    @Autowired
    private Service service;

    @PostMapping("/student/{group_id}")
    public void addStudent(@RequestBody Student student, @PathVariable(name = "group_id") int group_id) {
        service.addStudent(student, group_id);
    }

    @GetMapping("/student")
    public List<Student> getAllStudents() {
        return service.getAllStudents();
    }

    @PostMapping("/group")
    public void addGroup(@RequestBody Group group) {
        service.addGroup(group);
    }

    @GetMapping("/group")
    public List<Group> getAllGroups() {
        return service.getAllGroups();
    }
}
```

Теперь создадим репозиторий для сущности `Group`.

```java
public interface GroupRepository extends JpaRepository<Group, Integer> {}
```

Далее модифицируем класс сервиса. Добавим методы для добавления новой группы, а также для получения списка всех групп. Также модифицируем метод добавления новой группы. Метод работает следующим образом: получаем объект группы по id, после чего добавляем ссылку на группу в поле group объекта `Student`.

```java
@org.springframework.stereotype.Service
public class Service {

    @Autowired
    private StudentRepository studentRepo;

    @Autowired
    private GroupRepository groupRepo;

    public void addStudent(Student student, int id) {
        Group g = groupRepo.getOne(id);
        student.setGroup(g);
        studentRepo.save(student);
    }

    public List<Student> getAllStudents() {
        return studentRepo.findAll();
    }

    public void addGroup(Group group) {
        groupRepo.saveAndFlush(group);
    }

    public List<Group> getAllGroups() {
        return groupRepo.findAll();
    }
}
```

Запустим приложение и проверим его работу. Сначала добавим группу, после чего получим список групп.

Добавим новую группу

<p align="center">
  <img src="img/26.png" />
</p>

Получим список групп

<p align="center">
  <img src="img/27.png" />
</p>

Теперь добавим нового студента

<p align="center">
  <img src="img/28.png" />
</p>

Получим список всех групп

<p align="center">
  <img src="img/29.png" />
</p>
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
# Работа со Spring Security, часть 1

Spring Security – это фреймворк обеспечения безопасности, предоставляющий возможность декларативного управления безопасностью приложений на основе фреймворка Spring. В нем представлены базовые инструменты безопасности, которые без труда расширяются для решения разных задач.

## Основные понятия в Spring Security

- **Authentication** (аутентификация) - используется для подтверждения личности зарегистрированного пользователя. Проверка подлинности - это процесс проверки учетных данных: идентификатора пользователя (имени, адреса, электронной почты, номера телефона) и пароля. Процесс аутентификации - проверка того, что пользователь именно тот, за кого себя выдает;
- **Authorization** (авторизация) - происходит после того, как личность пользователя успешно аутентифицируется системой. Процесс авторизации определяет, имеет ли прошедший проверку человек доступ к определенным ресурсам: информации, файлам, базе данных;
- **Principal** - текущий пользователь или текущий аккаунт (если у одного физического лица или программы есть несколько аккаунтов, то тогда ему будет соответствовать несколько возможных principal`ов). Иногда, в общем случае, principal - это субъект, который принимает участие в осуществлении процедур безопасности. В качестве principal могут выступать люди, компьютеры, службы, процессы или их группа;
- **Granted Authority** - полномочие на выполнение некоторой операции (добавление пользователя, изменение данных, удаление сотрудника и так далее);
- **Role** - набор полномочий в виде роли в системе. Например, `ROLE_ADMIN` имеет набор полномочий (`READ`, `COMMENT`, `EDIT`, `DELETE`), а `ROLE_USER` имеет набор полномочий только (`READ`, `COMMENT`).

## Знакомство со Spring Security

Для подключения Spring Security необходимо добавить зависимость

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

Создадим новый Spring Boot - проект, подключим Spring MVC, Thymeleaf и Spring Security.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project ...>

    ...

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
    </dependencies>
</project>
```

Если мы сразу запустим наше приложение и попробуем зайти в браузере в корневой путь, мы увидим форму для аутентификации пользователя.

<p align="center">
  <img src="img/30.png" />
</p>

Форма логина находится по адресу `/login`. Форма для выхода из учетной записи находится по адресу `/logout`.

При подключении Spring Security, мы получаем по умолчанию следующие настройки безопасности:

- все HTTP-запросы требуют аутентификации;
- роли и полномочия не определены;
- аутентификация происходит с помощью простой страницы с формой;
- в системе есть только один пользовать с логином `user`.

Пароль для пользователя user можно обнаружить в логах при старте приложения, он каждый раз генерируется заново.

```plain
Using generated security password: cd2954e3-fb16-4943-970e-b650153b584a
```

### Настройки аутентификации

Для того, чтобы настроить аутентификацию пользователя, нам необходимо сконфигурировать кодировку паролей.

Создадим конфигурационный класс `SecurityConfig` и добавим в него бин `PasswordEncoder`.

```java
@Configuration
public class SecurityConfig {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

Кодировщик паролей (PasswordEncoder) используется при добавлении новых пользователей и при аутентификации существующих.

Библиотека Spring Security предоставляет несколько стандартных кодировщиков паролей:

- `BCryptPasswordEncoder` - алгоритм хеширования BCrypt;
- `NoOpPasswordEncoder` - пароль не хешируется;
- `Pbkdf2PasswordEncoder` - кодировка PBKDF2;
- `SCryptPasswordEncoder` - алгоритм хеширования SCrypt;
- `StandardPasswordEncoder` - алгоритм хеширования SHA-256.

Нужно понимать, что пароль никогда не хранится в открытом виде.

Когда регистрируется новый пользователь, введенный пароль кодируется и в базу данных записывается закодированный пароль (как правило, хеш пароля, который получен по определенному алгоритму).

Во время аутентификации, введенный пароль кодируется тем же алгоритмом и закодированное значение сравнивается со значением из базы данных. Если оба значения совпадают - значит пароль введен верно.

Далее необходимо настроить хранилище пользователей. Для этого нужно объявить бин типа `UserDetailsService`. Тип `UserDetailsService` является интерфейсом, в котором объявлен всего один метод `loadUserByUsername()`.

```java
public interface UserDetailsService {
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```

Этот метод принимает введенный пользователем логин и использует его для получения объекта `UserDetails`. Если объект с таким логином получить не удалось, метод выбрасывает исключение `UsernameNotFoundException`.

Библиотека Spring Security предоставляет несколько стандартных реализаций интерфейса `UserDetailsService`:

- хранилища пользователей в памяти;
- хранилище пользователей на основе JDBC;
- хранилище пользователей на основе LDAP.

Также, разработчик может предоставить свою реализацию данного интерфейса.

Для начала, попробуем создать хранилище пользователей в памяти. Такой вариант возможен, если в вашем приложении есть всего несколько пользователей и их количество не будет меняться.

Для быстрой настройки аутентификации необходимо переопределить метод `configure()` в классе-наследнике `WebSecurityConfigurerAdapter`. Обратите внимание, что метод `configure()` является перегруженным - существует три реализации этого метода. Для настройки аутентификации нам нужен метод, который принимает объект типа `AuthenticationManagerBuilder`.


Создадим хранилище в памяти с двумя пользователями "user" и "admin". Добавление пользователей происходит с помощью цепочки вызовов методов. Второй и следующие пользователи добавляются после метода `and()`.

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return NoOpPasswordEncoder.getInstance();
    }
    
    // Настройка аутентификации
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("user")
                .password("userpass")
                .roles("USER")
                .and()
                .withUser("admin")
                .password("adminpass")
                .roles("ADMIN");
    }
}
```

Добавим REST-контроллер с обработкой GET-методов для путей `/`, `/user` и `/admin`.

```java
@RestController
public class DefaultController {

    @GetMapping("/")
    public String root() {
        return "Hi all";
    }

    @GetMapping("/user")
    public String user() {
        return "Hi user!";
    }

    @GetMapping("/admin")
    public String admin() {
        return "Hi admin!";
    }
}
```

Далее запустим приложение, зайдем по адресу `http://localhost:8080` и попробуем воспользоваться учетными данными для user или для admin.

<p align="center">
  <img src="img/31.png" />
</p>

Если логин и пароль были введены верно мы получим результат обработки запроса методом контроллера.

<p align="center">
  <img src="img/32.png" />
</p>

На данный момент мы настроили процесс аутентификации, но не процесс авторизацию. Это значит, что любой кто прошел аутентификацию, может выполнить любые запросы к серверу.

Для того, чтобы разграничить доступ к ресурсам сервера, необходимо настроить процесс авторизации, чтобы указать кто и как может пользоваться ресурсами сервера. Давайте реализуем следующую логику авторизации:

- доступ по адресу `/` может осуществить любой;
- доступ по адресу `/user` может осуществить пользователь с ролью `USER` или `ADMIN`;
- доступ по адресу `/admin` может осуществить только пользователь с ролью `ADMIN`.

Для настройки авторизации нам тоже необходимо переопределить метод `configure()`, но перегруженный вариант, который принимает объект типа `HttpSecurity`.

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
            .antMatchers("/admin").hasRole("ADMIN")
            .antMatchers("/user").hasAnyRole("ADMIN", "USER")
            .antMatchers("/").permitAll()
            .and().formLogin();
}
```

Для указания пути используются Ant-style path patterns - специальная нотация для указания шаблонов пути. Подробную информацию читайте [здесь](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/AntPathMatcher.html).

Для каждого шаблона пути необходимо указать, пользователь с какой ролью авторизован для запроса с данным шаблоном пути. Если для авторизации нужна конкретная роль - используйте метод `hasRole()`, если для авторизации достаточно одной из ролей - метод `hasAnyRole()`. Метод `formLogin()` говорит о том, что для передачи данных учетной записи будет использоваться http-форма.

Запустим приложение и попробуем сделать запрос с адресом `http://localhost:8080/user`. Откроется окно с формой логина. Если мы введем данные для `user` или `admin`, мы успешно авторизуемся и получим данные от метода контроллера.

<p align="center">
  <img src="img/33.png" />
</p>

Если мы попытаемся перейти по адресу `http://localhost:8080/admin` без ввода логина и пароля или с учетной записью user, то получим ошибку 403 - запрошенный ресурс недоступен из-за ограничений безопасности.

<p align="center">
  <img src="img/34.png" />
</p>

Если же мы перейдем по адресу `http://localhost:8080/admin` с вводом учетной записи admin, то успешно получим ответ от сервера.

<p align="center">
  <img src="img/35.png" />
</p>
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
# Работа со Spring Security, часть 2

***Полный код файлов приведен в учебном проекте, который находится в директории с лекцией***

На данном занятии мы разберем использование Spring Security для регистрации и последующей аутентификации пользователя.

Напомним, что аутентификация - это проверка пользователя на то, является ли он тем, за кого себя выдает. Приложение спрашивает "кто ты?", а пользователь, например, вводит имя и пароль. Приложение проверяет, что такому имени действительно соответствует такой пароль и отвечает "ок, проверка пройдена".

Авторизация - это выдача прав (либо отказ в их выдаче). Этот процесс происходит уже после того, как пользователь подтвердил свою идентичность. Допустим, пользователь прошел аутентификацию и хочет попасть на url:

```plain
/admin
```

Приложение проверяет, какие стоят права у данного пользователя, и либо впускает его, либо нет.

Например, `user` может зайти на url `/user`, а `admin` на `/user` и еще на другие `url`.

## Создание проекта

Создадим новый Spring MVC проект. В нашем проекте будет 3 окна:

- окно логина (`/login`);
- окно регистрации (`/registration`);
- приветственная страница для пользователя (`/` или `/welcome`).

В новом проекте необходимо добавить следующие зависимости:

- Spring Data JPA
- Spring Security
- Thymeleaf
- Spring MVC
- PostgreSQL driver
- Lombok

### Регистрация пользователя

Создадим шаблон `registration.html` для страницы регистрации. Страница будет выглядеть следующим образом

<p align="center">
  <img src="img/36.png" />
</p>

Логика работы сценария регистрации пользователя будет следующая:

1. Пользователь вводит логин, пароль и подтверждает пароль;
2. Введенные данные проходят валидацию;
3. если данные не проходят валидацию, пользователю показываются сообщения об ошибках полей.
4. Новый пользователь записывается в базу данных;
5. Система автоматически аутентифицирует пользователя с введенными данными;
6. После аутентификации, система перенаправляет пользователя на приветственную страницу.

#### Создание сущностей

Создадим сущность `User`, которая будет моделировать пользователя в базе данных. Полный код класса представлен в учебном проекте, здесь просто укажем основные поля пользователя.

```java
public class User {

    private Long id;
    private String username;
    private String password;

    @Transient
    private String confirmPassword;

    // Отношения многие-ко-многим
    private Set<Role> roles;
}
```

Обратите внимание на аннотацию `@Transient` для поля `confirmPassword`. Она указывает JPA, что данное поле не надо сохранять в базе данных. В нашем случае, это поле будет использоваться только для того, чтобы провести валидацию пароля, в базе данных оно не нужно.

Также обратите внимание, что сущность `User` находится в отношениях многие-ко-многим с сущностью `Role`. Один пользователь может иметь много ролей в системе, одна роль может соответствовать многим пользователям.

Добавим сущность `Role`. Она отвечает за роль в сценариях аутентификации (`ROLE_USER`, `ROLE_ADMIN` и так далее).

```java
public class Role {

    private long id;
    private String name;
    
    // Отношения многие-ко-многим
    private Set<User> users;
}
```

#### Создание сервисов

Создадим сервис для сущности `User`. Сервис будет содержать два метода - сохранение нового пользователя в БД и получение объекта пользователя по его логину (если такой пользователь существует).

```java
public class UserService {

    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;

    public void save(User user) {
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        Set<Role> roles = new HashSet<>();
        roles.add(roleRepository.findById(1L).get());
        user.setRoles(roles);
        userRepository.save(user);
    }

    public User findByUsername(String username) {
        return userRepository.findByUsername(username);
    }
}
```

Давайте разберем последовательность действий в методе `save()`. Сначала мы должны зашифровать пароль, который ввел пользователь. Для этого, мы воспользуемся бином `PasswordEncoder` (мы его добавим позже, в настройках безопасности).

После этого, мы получаем из БД объект `Role` с `id = 1` (это будет `ROLE_USER`), устанавливаем эту роль пользователю и сохраняем пользователя в БД,

#### Создание репозиториев

Далее необходимо создать репозитории для сущностей `User` и `Role`. В интерфейс репозитория для сущности `User` мы добавим метод `findByUsername()`, который возвращает объект пользователя по его `username`. Этот метод понадобится нам для проверки уникальности логина при регистрации и для программной аутентификации пользователя после регистрации.

```java
public interface UserRepository extends JpaRepository<User, Long> {
    User findByUsername(String username);
}
```

```java
public interface RoleRepository extends JpaRepository<Role, Long> {}
```

#### Создание валидатора для формы регистрации

В предыдущим лекциях, для валидации формы мы использовали специальные аннотации, которые устанавливали для тех или иных полей сущности.

В этот раз необходимо обеспечить более сложную логику валидации данных, поэтому мы создадим свой класс валидатора, который будем использовать в сценарии регистрации нового пользователя.

Собственный класс валидатора должен наследоваться от интерфейса `Validator` из пакета `org.springframework.validation`. В данном интерфейсе объявлены следующие методы

```java
public interface Validator {
    boolean supports(Class<?> clazz);
    void validate(Object target, Errors errors);
}
```

Метод `supports()` определят, может ли разработанный валидатор произвести валидацию объектов указанного класса?

Метод `validate()` производит валидацию объекта `target`, и в случае возникновения ошибок, регистрирует их в объекте `errors`.

Давайте придумаем правила валидации для регистрационной формы:

- поле `username` не должно быть пустым;
- поле `username` должно быть длиной от 8 до 32 символов;
- поле `username` должно быть уникальным в системе;
- поле `password` не должно быть пустым;
- поле `password` должно быть длиной от 8 до 32 символов;
- поле `password` должно совпадать с полем `confirmPassword`.

Создадим класс UserValidator и реализуем эту логику валидации

```java
public class UserValidator implements Validator {

    private final UserService userService;

    @Override
    public boolean supports(Class<?> clazz) {
        return User.class.equals(clazz);
    }

    @Override
    public void validate(Object target, Errors errors) {
        User user = (User) target;

        // Поле username не должно быть пустым
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "username", "", "This field is required.");
        // Поле username должно быть длиной от 8 до 32 символов
        if (user.getUsername().length() < 8 || user.getUsername().length() > 32) {
            errors.rejectValue("username", "", "Username must be between 8 and 32 characters");
        }
        // Поле username должно быть уникальным в системе
        if (userService.findByUsername(user.getUsername()) != null) {
            errors.rejectValue("username", "", "Username is already exists.");
        }

        // Поле password не должно быть пустым
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "password", "", "This field is required.");
        // Поле password должно быть длиной от 8 до 32 символов
        if (user.getPassword().length() < 8 || user.getPassword().length() > 32) {
            errors.rejectValue("password", "", "password must be between 8 and 32 characters");
        }
        // Поле password должно совпадать с полем confirmPassword
        if (!user.getConfirmPassword().equals(user.getPassword())) {
            errors.rejectValue("password", "", "Passwords don't match!");
        }
    }
}
```

Для проверки поля на пустоту, мы используем готовый метод `rejectIfEmptyOrWhitespace()` из класса `ValidationUtils`. Для регистрации ошибок валидации, мы используем метод `rejectValue` объекта `errors`. Мы передаем название поля, название кода (используется для поддержки нескольких языков, мы просто передадим пустую строку) и текст ошибки валидации.

Для проверки `username` на уникальность, мы используем созданный ранее сервис `UserService` и пытаемся получить из БД объект пользователя для `username`, который введет при регистрации. Если мы получим объект - значит в БД уже есть пользователь с таким `username`, поэтому мы регистрируем ошибку валидации.

#### Создание контроллеров

Теперь необходимо создать контроллер и добавить методы для обработки запросов, которые возникают в сценарии регистрации пользователя.

Пока нам необходимо обработать передачу браузера страницы с формой регистрации и метод для обработки этой формы.

```java
public class UserController {

    private final UserService userService;
    private final UserValidator userValidator;

    // Передача браузеру страницы с формой
    @RequestMapping(value = {"/registration"}, method = RequestMethod.GET)
    public String registration(Model model) {
        model.addAttribute("userForm", new User());

        return "registration";
    }

    // Обработка данных формы
    @RequestMapping(value = "/registration", method = RequestMethod.POST)
    public String registration(@ModelAttribute("userForm") User userForm, BindingResult result, Model model) {
        
        // Валидация с помощью валидатора
        userValidator.validate(userForm, result);

        // Если есть ошибки - показ формы с сообщениями об ошибках
        if (result.hasErrors()) {
            return "registration";
        }

        // Сохранение пользователя в базе
        userService.save(userForm);

        // Перенаправление на приветственную страницу
        return "redirect:/welcome";
    }
}
```

#### Настройка аутентификации и авторизации

Теперь необходимо настроить Spring Security для обеспечения процесса аутентификации и авторизации.

Создадим класс SecurityConfig, в котором настроить аутентификацию и авторизацию.

```java
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    UserDetailsServiceImpl userDetailsService;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return NoOpPasswordEncoder.getInstance();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers("/registration", "/login").permitAll()
                .antMatchers("/", "/welcome").hasRole("USER")
                .and()
                .formLogin();
    }
}
```

Обратите внимание на объект класса UserDetailsServiceImpl. Данный класс будет рассмотрен ниже, он реализует интерфейс UserDetailsService.

Данный интерфейс является одним из ключевых в процессе аутентификации и он содержит всего один метод

```java
public interface UserDetailsService {
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```







Самым фундаментальным объектом в Spring Security является `SecurityContextHolder`. В нем хранится информация о текущем контексте безопасности приложения, который включает в себя подробную информацию о пользователе (principal), работающим с приложением. Spring Security использует объект `Authentication`, пользователя авторизованной сессии.

"Пользователь" - это просто объект. В большинстве случаев он может быть приведен к классу `UserDetails`. `UserDetails` можно представить, как адаптер между БД пользователей и тем, что требуется Spring Security внутри `SecurityContextHolder`.

Для создания `UserDetails` используется интерфейс `UserDetailsService`, с единственным методом.

```java
UserDetails loadUserByUsername(String username) throws UsernameNotFoundException 
```

В пакете `model` создадим класс сущности `Role`, который будет хранить роли в системе.

```java
@Entity
@Data
public class Role {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private long id;

    @Column(name = "name")
    private String name;

    @ManyToMany(mappedBy = "roles")
    private Set<User> users;
}
```

Обратите внимание, что таблицы `Role` и `User` будут находиться в отношении "многие-ко-многим".

Далее, в пакете `model`, создадим класс сущности `User`, который моделирует пользователя в системе.

```java
@Entity
@Table(name = "users")
@Data
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @Column(name = "username")
    private String username;

    @Column(name = "password")
    private String password;

    @Transient
    private String confirmPassword;

    @ManyToMany
    @JoinTable(
            name ="user_roles",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles;
}
```

Аннотация `@Transient` означает, что данное поле не будет сериализовано при добавлении сущности в БД.

Далее необходимо реализовать доступ к данным. Соединение с базой является важнейшей составляющей приложения. Как правило, выделяется часть кода, модуль, отвечающий за передачу запросов в БД и обработку полученных от нее ответов.

Для доступа к базе данных, как правило, используется шаблон проектирования **DAO** (Data Access Object). DAO - это абстрактный интерфейс к какому-либо типу базы данных или механизму хранения. По сути, DAO это прослойка между БД и системой. В Spring Data этот слой называется **Repository**.

Создадим интерфейс `RoleDao` и `UserDao` в пакете `dao`.

```java
public interface RoleDao extends JpaRepository<Role, Long> {
}
```

Обратите внимание, что для сущности `UserDao` мы определили метод интерфейса, который будет возвращать объект `User` по `username` пользователя.

```java
public interface UserDao extends JpaRepository<User, Long> {
    User findByUsername(String username);
}
```

Далее необходимо создать классы для слоя сервисов. В пакете `services` объявим интерфейс `UserService` и класс `UserServiceImpl`, который реализует этот интерфейс.

```java
public interface UserService {
    void save(User user);
    User findByUsername(String username);
}
```

```java
@Service
public class UserServiceImpl implements UserService {

    private UserDao userDao;
    private RoleDao roleDao;
    private BCryptPasswordEncoder passwordEncoder;

    @Autowired
    public UserServiceImpl(UserDao userDao, RoleDao roleDao, BCryptPasswordEncoder passwordEncoder) {
        this.userDao = userDao;
        this.roleDao = roleDao;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public void save(User user) {
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        Set<Role> roles = new HashSet<>();
        roles.add(roleDao.getById(1L));
        user.setRoles(roles);
        userDao.save(user);
    }

    @Override
    public User findByUsername(String username) {
        return userDao.findByUsername(username);
    }
}
```

Далее необходимо написать реализацию интерфейса `UserDetailsService` - класс `UserDetailsServiceImpl`.

Интерфейс `UserDetailsService` используется для получения данных пользователя. В нем объявлен всего один метод `loadUserByUsername()`.

```java
public interface UserDetailsService {
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```

Этот метод принимает введенный пользователем логин и использует его для получения объекта `UserDetails`. Если объект с таким логином получить не удалось, метод выбрасывает исключение `UsernameNotFoundException`.

Возвращаемый `UserDetails` представляет собой интерфейс, который предоставляет геттеры, которые гарантируют not-null результаты аутентификационной информации, такие как имя пользователя, пароль, предоставленные полномочия и является ли учетная запись пользователя заблокированной или нет.

```java
public class UserDetailsServiceImpl implements UserDetailsService {

    private UserDao userDao;

    public UserDetailsServiceImpl(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userDao.findByUsername(username);

        Set<GrantedAuthority> grantedAuthorities = new HashSet<>();

        for (Role role : user.getRoles()) {
            grantedAuthorities.add(new SimpleGrantedAuthority(role.getName()));
        }

        return new org.springframework.security.core.userdetails.User(user.getUsername(), user.getPassword(), grantedAuthorities);
    }
}
```
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
# Работа со Spring Security, часть 3

Аутентификация на основе сессий

Протокол HTTP не отслеживает состояния (является stateless протоколом). Это означает, что каждый запрос выполняется независимо, без информации о предыдущих запросах. Серверу не нужно хранить информацию о статусе каждого клиента на протяжении нескольких запросов от него. Такой подход позволяет минимизировать потребление ресурсов сервером, а также сократить количество данных, которые передаются между клиентом и сервером.

Многим приложениям необходимо отслеживать статус и состояние клиента, например, чтобы кастомизировать содержимое страницы для конкретного пользователя. Для реализации такого функционала есть несколько способов:

**Аутентификация на основе сессий**

Одним из способов отслеживать состояния пользователя является аутентификация на основе сессий с использованием cookies.

HTTP cookie (web cookie, куки браузера) - это небольшой фрагмент данных, который сервер отправляет браузеру пользователя. Браузер может сохранить этот фрагмент у себя и отправлять на сервер с каждым последующим запросом. Это, в частности, позволяет узнать, с одного ли сервера пришли несколько запросов. С помощью кук можно сохранить любую информацию о состоянии. Куки часто используются для:

- управления сеансом (логины, корзины для виртуальных покупок);
- персонализации (пользовательские предпочтения);
- трекинга (отслеживание поведения пользователей.)

С технической точки зрения, куки - это обычные HTTP-заголовки.

В случае сценария аутентификации, куки хранят информацию об id сессии. Сессии придуманы для того, чтобы сервер "помнил" пользователя при повторных запросах от него. То есть, пользователь вводит однократно имя и пароль, и при дальнейших запросах сервер понимает, от кого именно пришел запрос, а также какие объекты есть в данном сеансе (например, товары в корзине покупок).

>Пояснить взаимодействие с сервером можно на примере обращения в службу поддержки. При первом обращении клиент описывает проблему и получает номер обращения (**JSESSIONID**). Дальше переписка идет под этим номером обращения. Клиенту не надо каждый раз заново все пересказывать. Служба поддержки (сервер) по номеру сама восстанавливает все детали (идентичность пользователя и данные сессии).

Реализуется это с помощью идентификаторов сессий. Стандартный алгоритм следующий:

1 Сервер высылает клиенту при первом запросе (например, при успешном логине, но можно и анонимному клиенту) заголовок типа

```Set-Cookie: JSESSIONID=4C7871D1EF406F69C7CF20CD6BD283F1```

2 Браузер сохраняет эти значения (свои для каждого сайта), и далее при каждом запросе на конкретный сайт браузер автоматически добавляет к запросу соответствующий заголовок:

```Cookie: JSESSIONID=4C7871D1EF406F69C7CF20CD6BD283F1```

> Название JSESSIONID не универсально, а характерно именно для Java. В других языках используются другие названия.

При последующих запросах от того же клиента, сервер опознает клиента по идентификатору сессии. Контейнер хранит эти идентификаторы сессий и соответствующие данные клиента как словарь в Map. Сессия имеет срок годности. Как только она истекает, данные исчезают, и в последующих запросах контейнер не принимает истекший Cookie конкретного клиента.

Метод аутентификации JWT является одним из самых распространенных методов аутентификации запросов на WEB-приложения и позволяет защитить REST API.

Данный вид защиты и аутентификации имеет ряд преимуществ:

- удобство (не нужно при каждом запросе передавать логин и пароль);
- меньше запросов к БД (токен может содержать в себе базовую информацию о пользователе);
- простота реализации (достаточно использовать готовую библиотеку для генерации и расшифровки токена).

Токен - это просто строка, которая генерируется по запросу пользователя, который хочет в дальнейшем вызывать защищенные ресурсы.
